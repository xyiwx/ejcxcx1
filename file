local pui = require('gamesense/pui')
local bit = require('bit')
local clipboard = require('gamesense/clipboard')
local json = require('json')
local ffi  = require('ffi')
local base64 = require('gamesense/base64')
local c_entity = require('gamesense/entity')
local vector = require('vector')
local flags = entity.get_prop(entity.get_local_player(), 'm_fFlags')
a = function(...) return ... end
return(function(r)
    local auto, database, anomaly, menu, wtx, debug, data, eui, memory, builder = { }, { }, { }, { }, { }, { }, { }, { }, { }, { }
    local old_client = client
    client = old_client
    menu.celestium = {}
    menu.celestium.builder   = { }
    menu.celestium.visual    = { }
    menu.celestium.misc      = { }
    data.threat_origin       = 0
    data.__index = setmetatable(data, {})
    eui.__index = eui
    memory.delay_number = 0
    memory.number       = 0
    memory.number_anim  = 0
    function eui:new(value)
        local add_meta = setmetatable({ }, self)
        add_meta.value = value
        return add_meta
    end
    function eui:call(...)
        if type(self.value) == 'function' then
            return self.value(...)
        elseif type(self.value) == 'table' then 
            local t = { }
            for _, value in ipairs(self.value) do
                if type(value) == 'function' then
                    table.insert(t, value(...))
                else
                    table.insert(t, value)
                end
            end
            return t
        else
            return self.value
        end
    end
    do(function()
        set_antiaimbot_visible = a(function(call)
            call = not call
            do
                auto.refs.antiaim.slowwalk[1]:set_visible(call)
                auto.refs.antiaim.legmmovement:set_visible(call)
                auto.refs.antiaim.osaa[1]:set_visible(call)
                auto.refs.antiaim.fakepeek[1]:set_visible(call)
            end
            do
                auto.refs.antiaim.enabled_fl[1]:set_visible(call)
                auto.refs.antiaim.amount:set_visible(call)
                auto.refs.antiaim.variance:set_visible(call)
                auto.refs.antiaim.limit:set_visible(call)
            end
            do
                auto.refs.antiaim.enabled:set_visible(call)
                auto.refs.antiaim.pitch[1]:set_visible(call)
                auto.refs.antiaim.pitch[2]:set_visible(call)
                auto.refs.antiaim.yawbase:set_visible(call)
                auto.refs.antiaim.yaw[1]:set_visible(call)
                auto.refs.antiaim.yaw[2]:set_visible(call)
                auto.refs.antiaim.jitter[1]:set_visible(call)
                auto.refs.antiaim.jitter[2]:set_visible(call)
                auto.refs.antiaim.desync[1]:set_visible(call)
                auto.refs.antiaim.desync[2]:set_visible(call)
                auto.refs.antiaim.freestand[1]:set_visible(call)
                auto.refs.antiaim.freestanding_bodyyaw:set_visible(call)
                auto.refs.antiaim.edgeyaw[1]:set_visible(call)
                auto.refs.antiaim.roll:set_visible(call)
            end
        end)
    end)()end
    do(function()
        local rage, aa, cont, fl, ot, aimbot = a((function()
            return 'RAGE'
        end)(), a(function()
            return 'AA'
        end)(), a(function()
            return 'Anti-aimbot angles'
        end)(), a(function()
            return 'Fake lag'
        end)(), a(function()
            return 'Other'
        end)(), a(function()
            return 'Aimbot'
        end)())
        auto.refs = {
            antiaim = {
                enabled   =  r(aa, cont, 'Enabled'),
                pitch     = {r(aa, cont, 'Pitch')},
                yaw       = {r(aa, cont, 'Yaw')},
                yawbase   = r(aa, cont, 'Yaw base'),
                jitter    = {r(aa, cont, 'Yaw jitter')},
                desync    = {r(aa, cont, 'Body yaw')},
                freestanding_bodyyaw =  r(aa, cont, 'Freestanding body yaw'),
                edgeyaw   =  {r(aa, cont, 'Edge yaw')},
                freestand = {r(aa, cont, 'Freestanding')},
                roll      =  r(aa, cont, 'Roll'),

                enabled_fl   = {r(aa, fl, 'Enabled')},
                amount    = r(aa, fl, 'Amount'),
                variance  = r(aa, fl, 'Variance'),
                limit     = r(aa, fl, 'Limit'),
                slowwalk  = {r(aa, ot, 'Slow motion')},
                legmmovement=r(aa, ot, 'Leg movement'),
                osaa      = {r(aa, ot, 'On shot anti-aim')},
                fakepeek  = {r(aa, ot, 'Fake peek')},

                fakeduck  = r(rage, ot, 'Duck peek assist')
            },
            rage = {
                dt        = {r(rage, aimbot, 'Double tap')}
            }
        }
    end)()end
    normalize = function(x, z)
        __offset = eui:new(function(x, min, max)
            local delta = max - min
            while x > max do
                x = x - delta
            end
    
            while x < min do
                x = x + delta
            end
    
            return x
        end)
        if z == 'yaw' then
            return __offset:call(x, -180, 180)
        elseif z == 'pitch' then
            return __offset:call(x, -89, 89)
        end
    end
    anomaly = {
        angles = pui.group('AA', 'Anti-aimbot angles'),
        fakelag = pui.group('AA', 'Fake lag'),
        other = pui.group('AA', 'Other'),
    }
    do(function()
        do ----------------------< menu helpers >----------------------
            wtx = setmetatable({
                ui_color = a(function(e, t, c)
                    c = c or (function()
                        return 'EAA7D7FF'
                    end)()
                    return e .. ('\a' .. c) .. t
                end)
            }, {
                __call = function(self, e, t, c)
                    return self.ui_color(e, t, c)
                end
            })
        end
        do ----------------------< antiaim helpers >----------------------

        end
        local tickbase = setmetatable({
            local_player = function()
                return entity.get_prop(entity.get_local_player(), 'm_nTickBase')
            end
        }, {
            __call = function(self)
                return self.local_player()
            end
        })
    end)()end
    do(function()
        database.in_air_ticks = 0
        database['player_states'] = {'global', 'standing', 'moving', 'slowmotion', 'aero', 'aero+c', 'crouch', 'crouch+moving', 'fakeduck', 'fakelag', 'freestanding', 'hideshots', 'warmup', 'noenemies'}
        database['aa:defensive'] = not database['aa:defensive']
        database['disabler_function'] = (function()
            local alive = 0
    
            for i = 1, globals.maxplayers() do
                if entity.get_classname(i) ~= 'CCSPlayer' then
                    goto skip
                end
    
                if not entity.is_alive(i) or not entity.is_enemy(i) then
                    goto skip
                end
    
                alive = alive + 1
                ::skip::
            end
    
            return alive
        end)
        database['enemy_distance'] = (function()
            dist = (function(x1, y1, z1, x2, y2, z2)
                return math.sqrt((x2 - x1) ^ 2 + (y2 - y1) ^ 2 + (z2 - z1) ^ 2)
            end)
            local players = entity.get_players(true)
            local lx, ly, lz = entity.get_prop(entity.get_local_player(), 'm_vecOrigin')
            if players == nil then return end
            for i = 1, #players do
                local x, y, z = entity.get_prop(players[i], 'm_vecOrigin')
                local distance = dist(lx, ly, lz, x, y, z)
                local weapon = entity.get_player_weapon(players[i])
                local get_knife = entity.get_classname(weapon)
                if distance ~= nil then
                    return {distance = distance, weapon = get_knife}
                else
                    return {distance = nil, weapon = 'undefined'}
                end
            end
        end)
        database['delay:ticks'] = (function(delay,cmd)
            local ticks = function()
                return math.floor(entity.get_prop(entity.get_local_player(), 'm_nTickBase') * 4 / 8)
            end
                if cmd.chokedcommands == 0 then
                    if ticks() % delay + 1 == delay then
                        database['switch'] = not database['switch']
                    end
                end
            return database['switch']
        end)
        database['velocity'] = function()
            if not entity.get_local_player() then return end
            local first_velocity, second_velocity = entity.get_prop(entity.get_local_player(), 'm_vecVelocity')
            local speed = math.floor(math.sqrt(first_velocity*first_velocity+second_velocity*second_velocity))
            
            return speed
        end
        database['aa:states'] = function(database)
            local flags = entity.get_prop(entity.get_local_player(), 'm_fFlags')
            local data = eui:new(function(n)
                return builder[n]['enable']:get()
            end)
            if database['disabler_function']() == 0 and data:call(14) then
                return 14
            else
                if entity.get_prop(entity.get_game_rules(), 'm_bWarmupPeriod') == 1 and data:call(13) then
                    return 13
                else
                    if auto.refs.antiaim.freestand[1].hotkey:get() and data:call(11)then
                        return 11
                    else
                        if auto.refs.antiaim.fakeduck:get() and data:call(9) then
                            return 9
                        else
                            if (not auto.refs.antiaim.osaa[1].hotkey:get() and not auto.refs.rage.dt[1].hotkey:get()) and data:call(10) then
                                return 10
                            else
                                if auto.refs.antiaim.osaa[1].hotkey:get() and data:call(12) then
                                    return 12
                                else
                                    if bit.band(flags, 1) == 1 then
                                        if database.in_air_ticks > -1 and database.in_air_ticks < 6 then
                                            if bit.band(flags, 4) == 4 then
                                                return 6
                                            else
                                                return 5
                                            end
                                        end
                                        if database['velocity']( ) > 5 and (bit.band(flags, 4) == 4) or auto.refs.antiaim.fakeduck:get() then
                                            return 8
                                        end
                                        if bit.band(flags, 4) == 4 or auto.refs.antiaim.fakeduck:get() then
                                            return 7
                                        else
                                            if database['velocity']( ) <= 3 then
                                                return 2
                                            else
                                                if auto.refs.antiaim.slowwalk[1].hotkey:get() then
                                                    return 4
                                                else
                                                    return 3
                                                end
                                            end
                                        end
                                    elseif bit.band(flags, 1) == 0 then
                                        if bit.band(flags, 4) == 4 then
                                            return 6
                                        else
                                            return 5
                                        end 
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end)()end
    do(function()
        do ------------< add local values >----------
            debug = setmetatable(
            {
                unpack = function(s)
                    return table.unpack(s)
                end,
                add_label = eui:new(function(tab, text)
                    local diff = {
                        ['aa'] = anomaly.angles,
                        ['fl'] = anomaly.fakelag,
                        ['other'] = anomaly.other,
                    }
                    menu.f = diff[tab]:label(text)
                    return menu.f
                end),    
                add_handler = eui:new(function(len, text, forceline)
                    forceline = forceline or false
                    text = text or ''
                    local lines = string.rep('‾', len)
                    return '\a404040FF' .. ((forceline and ' ' or '') .. lines .. (forceline == false and ('*< ' .. text .. ' >*') or ('')) .. lines)
                end),
                add_trash_label = function(tab)
                    local diff = {
                        ['aa'] = anomaly.angles,
                        ['fl'] = anomaly.fakelag,
                        ['other'] = anomaly.other,
                    }
                    menu.t = diff[tab]:label('\n')
                    return menu.t
                end
            }, {
                __index  = debug
            })
            debug.unpack = function(s)
                return table.unpack(s)
            end
        end
        menu.masterkey = anomaly.fakelag:checkbox('c  e  l  e  s  t  i  u  m')
        menu.f = anomaly.angles:label(' C      E      L      E      S      T      I      U      M'):depend(menu.masterkey)
        debug.add_trash_label('aa'):depend(menu.masterkey)
        debug.add_trash_label('aa'):depend(menu.masterkey)
        debug.add_trash_label('fl'):depend(menu.masterkey)
        menu.user = anomaly.fakelag:label(wtx.ui_color('welcome back, ', 'user')):depend(menu.masterkey)
        menu.version = anomaly.fakelag:label(wtx.ui_color('version: ', 'exclusive')):depend(menu.masterkey)
        menu.lastupdate = anomaly.fakelag:label(wtx.ui_color('last update: ', '3.11.24')):depend(menu.masterkey)
        debug.add_trash_label('fl'):depend(menu.masterkey)
        debug.add_trash_label('fl'):depend(menu.masterkey)
        menu.tabs = anomaly.fakelag:combobox('\n', {'                         home', '                     antiaimbot', '                         visual', '                          misc', '                         config'}):depend(menu.masterkey)
        menu.tabs1 = anomaly.fakelag:combobox('\n', {'                       settings', '                        builder', '                      defensive'}):depend(menu.masterkey, {menu.tabs, '                     antiaimbot'})
        local __tabs = {
            [0] = {
                [0] = {{menu.tabs, '                         home'}, menu.masterkey},
                [1] = {{menu.tabs, '                     antiaimbot'}, menu.masterkey},
                [2] = {
                    [0] = {{menu.tabs, '                     antiaimbot'}, {menu.tabs1, '                       settings'}, menu.masterkey},
                    [1] = {{menu.tabs, '                     antiaimbot'}, {menu.tabs1, '                        builder'}, menu.masterkey},
                    [2] = {{menu.tabs, '                     antiaimbot'}, {menu.tabs1, '                        builder', '                      defensive'},  menu.masterkey},
                    [3] = {{menu.tabs, '                     antiaimbot'}, {menu.tabs1, '                      defensive'}, menu.masterkey}
                }
            },
            [1] = {
                [0] = {{menu.tabs, '                         visual'}, menu.masterkey},
                [1] = {{menu.tabs, '                          misc'}, menu.masterkey},
                [2] = {{menu.tabs, '                         config'}, menu.masterkey}
            }
        }

        do -------------------< home >----------------------
            debug.add_label:call('aa', debug.add_handler:call(10, 'fast config')):depend(
                debug.unpack(__tabs[0][0])
            )
            debug.add_trash_label('aa'):depend(
                debug.unpack(__tabs[0][0])
            )
            menu.celestium.export_fast_config = anomaly.angles:button('export config', function() 

            end):depend(
                debug.unpack(__tabs[0][0])
            )
            menu.celestium.import_fast_config = anomaly.angles:button('import config', function() 

            end):depend(
                debug.unpack(__tabs[0][0])
            )
        end
        do -------------------< antiaimbot >---------------------
            debug.add_label:call('aa', debug.add_handler:call(11, 'antiaim')):depend(
                debug.unpack(__tabs[0][1])
            )
            do ---------------------------< settings >--------------------------------
                menu.celestium.avoidbackstap = anomaly.angles:checkbox('avoid backstap'):depend(debug.unpack(__tabs[0][2][0]))
                menu.celestium.extended_fakeduck = anomaly.angles:checkbox('extended ticks of fakeduck'):depend(debug.unpack(__tabs[0][2][0]))
                menu.celestium.safehead = anomaly.angles:checkbox('safe head'):depend(
                    debug.unpack(__tabs[0][2][0])
                ) do
                    menu.celestium.safehead.weapons = anomaly.angles:multiselect('\n\n---', {'knife', 'taser', 'scout', 'awp'}):depend(
                        menu.celestium.safehead,
                        debug.unpack(__tabs[0][2][0])
                    )
                end
                menu.celestium.fakeflick = anomaly.angles:checkbox('\aCCCC6FFFfakeflick'):depend(
                    debug.unpack(__tabs[0][2][0])
                ) do
                    menu.celestium.fakeflick.flick_type = anomaly.angles:combobox('\nflick', {'classic', 'slow', 'fast', 'random'}):depend(
                        menu.celestium.fakeflick,
                        debug.unpack(__tabs[0][2][0])
                    )
                    menu.celestium.fakeflick_hotkey = anomaly.angles:hotkey('fakeflick_hotkey'):depend(
                        menu.celestium.fakeflick,
                        debug.unpack(__tabs[0][2][0])
                    )
                end
                menu.celestium.manualyaw = anomaly.angles:checkbox('manual yaw'):depend(debug.unpack(__tabs[0][2][0])) do
                    menu.celestium.manualyaw.left = anomaly.angles:hotkey('left'):depend(
                        menu.celestium.manualyaw,
                        debug.unpack(__tabs[0][2][0])
                    )
                    menu.celestium.manualyaw.right = anomaly.angles:hotkey('right'):depend(
                        menu.celestium.manualyaw,
                        debug.unpack(__tabs[0][2][0])
                    )
                    menu.celestium.manualyaw.forward = anomaly.angles:hotkey('forward'):depend(
                        menu.celestium.manualyaw,
                        debug.unpack(__tabs[0][2][0])
                    )
                    menu.celestium.manualyaw.back = anomaly.angles:hotkey('back'):depend(
                        menu.celestium.manualyaw,
                        debug.unpack(__tabs[0][2][0])
                    )
                end 
                menu.celestium.freestanding = anomaly.angles:hotkey('freestanding'):depend(
                    debug.unpack(__tabs[0][2][0])
                )
                menu.celestium.edgeyaaw = anomaly.angles:hotkey('edgeyaw'):depend(
                    debug.unpack(__tabs[0][2][0])
                )
                menu.celestium.fakelag = anomaly.angles:combobox('fakelag', {'fluctuate', 'random', 'maximum', 'dynamic'}):depend(debug.unpack(__tabs[0][2][0]))
            end
            do ---------------------------< builder >--------------------------------
                menu.celestium.builder.states = anomaly.angles:combobox('\n', database['player_states']):depend(
                    debug.unpack(__tabs[0][2][2])
                )  
                for i = 1, #database['player_states'] do
                    local diff = {    ' ',
                    '  ',
                    '   ',
                    '    ',
                    '     ',
                    '      ',
                    '       ',
                    '        ',
                    '         ',
                    '          ',
                    '           ',
                    '            ',
                    '             ',
                    '              ',
                    '               ',
                    '                ',
                    '                 ',
                    '                  ',
                    '                   ',
                    '                    ',
                    '                     ',
                    '                      ',
                    '                       ',
                    '                        ',
                    '                         ',
                    '                          ',
                    '                           ',
                    '                            ',
                    '                             ',
                    '                              ',
                    '                               ',
                    '                                ',
                    '                                 ',
                    '                                  ',
                    '                                   ',
                    '                                    ',
                    '                                     ',
                    '                                      ',
                    '                                       ',
                    '                                        ',
                    '                                         ',
                    '                                          ',
                    '                                           ',
                    '                                            ',
                    '                                             ',
                    '\n ',
                    '\n  ',
                    '\n   ',
                    '\n    ',
                    '\n     ',
                    '\n      ',
                    '\n       ',
                    '\n        ',
                    '\n         ',
                    '\n          ',
                    '\n           ',
                    '\n            ',
                    '\n             ',
                    '\n              ',
                    '\n               ',
                    '\n                ',
                    '\n                 ',
                    '\n                  ',
                    '\n                   ',
                    '\n                    ',
                    '\n                     ',
                    '\n                      ',
                    '\n                       ',
                    '\n                        ',
                    }
                    builder[i] = { }
 
                    builder[i]['enable'] = anomaly.angles:checkbox(wtx.ui_color('allow ', database['player_states'][i]) .. '\aFFFFFFB2 state')
                    builder[i]['pitch'] = anomaly.angles:combobox('pitch' .. diff[i], {'off', 'down', 'up', 'zero', 'custom'})
                    builder[i]['pitch:slider'] = anomaly.angles:slider('\n\n               ' .. diff[i], -89, 89, 0, 1)
                    builder[i]['yawbase'] = anomaly.angles:combobox('yawbase' .. diff[i], {'at targets', 'local viewtopic'})
                    builder[i]['yaw'] = anomaly.angles:combobox('yaw' .. diff[i], {'off', '180', 'spin', 'static', '180z', 'crosshair', 'delay', 'random'})
                    builder[i]['yaw:offset1'] = anomaly.angles:slider('\n\n\n--' .. diff[i], -60, 60 , 0, 1) -- *3
                    builder[i]['yaw:delay:offset1'] = anomaly.angles:slider('left' .. diff[i], -45, 45, 0, 1) -- *2
                    builder[i]['yaw:delay:offset2'] = anomaly.angles:slider('right' .. diff[i], -45, 45, 0, 1) -- *2
                    builder[i]['yaw:delay:delay'] = anomaly.angles:slider('delay' .. diff[i], 2, 32, 2, 1, 't')
                    builder[i]['jitter'] = anomaly.angles:combobox('jitter' .. diff[i], {'off', 'offset', 'center', 'random', 'skitter', 'sway'})
                    builder[i]['jitter:offset1'] = anomaly.angles:slider('\n\n-\n-----\n-3---33-' .. diff[i], -90, 90, 0, 1) -- *2
                    builder[i]['jitter:center1'] = anomaly.angles:slider('\n\n--1--1-\n--' .. diff[i], -60, 60, 0, 1) -- *3
                    builder[i]['jitter:sway_speed'] = anomaly.angles:slider('speed' .. diff[i], 2, 32, 0, 1, 't')
                    builder[i]['desync'] = anomaly.angles:combobox('desync' .. diff[i], {'off', 'opposite', 'jitter', 'static'})
                    builder[i]['desync:offset1'] = anomaly.angles:slider('\n\n  ' .. diff[i], -60, 60, 0, 1)

                    builder[i]['trash'] = anomaly.angles:label('\n\n-' .. diff[i])
                    builder[i]['defensive'] = anomaly.angles:checkbox('force defensive\n---' .. diff[i])
                    builder[i]['defensive:type'] = anomaly.angles:combobox('\n\n---\n---' .. diff[i], {'always on', 'on peek', 'celestium'})
                    builder[i]['defensive:trash'] = anomaly.angles:label('\n\n\n---  ' .. diff[i])
                    builder[i]['defensive:pitch'] = anomaly.angles:combobox('pitch\n\n\\n' .. diff[i], {'off', 'up', 'zero', 'down', 'random', 'delayed random', 'spin', 'skitter', 'custom'})
                    builder[i]['defensive:pitch:custom'] = anomaly.angles:slider('\n\n---' .. diff[i], -89, 89, 0, 1)
                    builder[i]['defensive:pitch:speed'] = anomaly.angles:slider('speed\n---\n---' .. diff[i], -60, 60)
                    builder[i]['defensive:yaw'] = anomaly.angles:combobox('yaw\n\n\n' .. diff[i], {'off', '180', '360', 'side', 'skitter', 'random', 'delayed random', 'sideways', 'invertways', 'spin', 'absolute spin', 'custom'})
                    builder[i]['defensive:yaw:custom'] = anomaly.angles:slider('\n\n--- ' .. diff[i], -180, 180, 0, 1)
                    builder[i]['defensive:yaw:spin'] = anomaly.angles:slider('speed\n---' .. diff[i], -60, 60)
                    builder[i]['trash1'] = anomaly.angles:label('\n\n-' .. diff[i])
                    builder[i]['defensive:duration'] = anomaly.angles:slider('duration' .. diff[i], 1, 4, 1, true, '', 1, {[1] = 'default', [2] = 'celestium', [3] = 'extended', [4] = 'break'})
                end
                for i = 1, #database['player_states'] do
                    local zxc = builder[i]['enabled']
                    local ist = {zxc, function( ) if(i == 1) then return true else return builder[i]['enabled']:get( ) end end}
                    local isaa = debug.unpack(__tabs[0][2][1])
                    local isdef = debug.unpack(__tabs[0][2][3])

                    local aa = {menu.celestium.builder.states, database['player_states'][i]}

                    local ready = debug.unpack({aa, ist})
                    local ready_def = aa

                    builder[i]['enable']:depend(menu.masterkey, isaa, aa ,{menu.celestium.builder.states, function( ) return (z ~= 1) end}, {menu.tabs1, '                        builder'})

                    builder[i]['pitch']:depend(menu.masterkey, builder[i]['enable'], isaa, ready, {menu.tabs1, '                        builder'})
                    builder[i]['pitch:slider']:depend(menu.masterkey, builder[i]['enable'],isaa, ready, {builder[i]['pitch'], 'custom'}, {menu.tabs1, '                        builder'})
                    builder[i]['yawbase']:depend(menu.masterkey, builder[i]['enable'],isaa, ready, {menu.tabs1, '                        builder'})
                    builder[i]['yaw']:depend(menu.masterkey, builder[i]['enable'],isaa, ready, {menu.tabs1, '                        builder'})
                    builder[i]['yaw:offset1']:depend(menu.masterkey, builder[i]['enable'],isaa, ready, {builder[i]['yaw'], '180', 'spin', 'static', '180z', 'crosshair', 'random'}, {menu.tabs1, '                        builder'})
                    builder[i]['yaw:delay:offset1']:depend(menu.masterkey, builder[i]['enable'],isaa, ready, {builder[i]['yaw'], 'delay'}, {menu.tabs1, '                        builder'})
                    builder[i]['yaw:delay:offset2']:depend(menu.masterkey, builder[i]['enable'],isaa, ready, {builder[i]['yaw'], 'delay'}, {menu.tabs1, '                        builder'})
                    builder[i]['yaw:delay:delay']:depend(menu.masterkey, builder[i]['enable'],isaa, ready, {builder[i]['yaw'], 'delay'}, {menu.tabs1, '                        builder'})
                    builder[i]['jitter']:depend(menu.masterkey, builder[i]['enable'],isaa, ready, {menu.tabs1, '                        builder'})
                    builder[i]['jitter:offset1']:depend(menu.masterkey, builder[i]['enable'],isaa, ready, {builder[i]['jitter'], 'offset', 'random', 'sway', 'skitter'}, {menu.tabs1, '                        builder'})
                    builder[i]['jitter:center1']:depend(menu.masterkey, builder[i]['enable'],isaa, ready, {builder[i]['jitter'], 'center'}, {menu.tabs1, '                        builder'})
                    builder[i]['jitter:sway_speed']:depend(menu.masterkey, builder[i]['enable'],isaa, ready, {builder[i]['jitter'], 'sway'}, {menu.tabs1, '                        builder'})
                    builder[i]['desync']:depend(menu.masterkey, builder[i]['enable'],isaa, ready, {menu.tabs1, '                        builder'})
                    builder[i]['desync:offset1']:depend(menu.masterkey, builder[i]['enable'],isaa, ready, {builder[i]['desync'], 'opposite', 'jitter', 'static'}, {menu.tabs1, '                        builder'})

                    builder[i]['trash']:depend(menu.masterkey, isdef, ready_def, {menu.tabs1, '                      defensive'})
                    builder[i]['defensive']:depend(menu.masterkey, isdef, ready_def, {menu.tabs1, '                      defensive'})
                    builder[i]['defensive:type']:depend(menu.masterkey, isdef, ready_def,  builder[i]['defensive'], {menu.tabs1, '                      defensive'})
                    builder[i]['defensive:trash']:depend(menu.masterkey, isdef, ready_def, builder[i]['defensive'], {menu.tabs1, '                      defensive'})    
                    builder[i]['defensive:pitch']:depend(menu.masterkey, isdef, ready_def, builder[i]['defensive'], {menu.tabs1, '                      defensive'})
                    builder[i]['defensive:pitch:custom']:depend(menu.masterkey, isdef, ready_def, builder[i]['defensive'], {menu.tabs1, '                      defensive'}, {builder[i]['defensive:pitch'], 'custom'})
                    builder[i]['defensive:pitch:speed']:depend(menu.masterkey, isdef, ready_def, builder[i]['defensive'], {menu.tabs1, '                      defensive'}, {builder[i]['defensive:pitch'], 'delayed random', 'spin'})
                    builder[i]['defensive:yaw']:depend(menu.masterkey, isdef, ready_def, builder[i]['defensive'], {menu.tabs1, '                      defensive'})
                    builder[i]['defensive:yaw:custom']:depend(menu.masterkey, isdef, ready_def, builder[i]['defensive'], {menu.tabs1, '                      defensive'}, {builder[i]['defensive:yaw'], 'custom'})
                    builder[i]['defensive:yaw:spin']:depend(menu.masterkey, isdef, ready_def, builder[i]['defensive'], {menu.tabs1, '                      defensive'}, {builder[i]['defensive:yaw'], 'delayed random', 'spin'})
                    builder[i]['trash1']:depend(menu.masterkey, isdef, ready_def, {menu.tabs1, '                      defensive'})
                    builder[i]['defensive:duration']:depend(menu.masterkey, isdef, ready_def, builder[i]['defensive'], {menu.tabs1, '                      defensive'})
                end
            end
        end
        do -----------------------< visuals >---------------------------
            menu.celestium.visual.animbreaker = anomaly.other:multiselect('\aCCCC6FFFanimlayer', {'fallen legs', 'movelean', 'reset pitch on land', 'static legs', 'earth quake', 'blind', 'kangoroo', 'smooth'}):depend(
                debug.unpack(__tabs[1][0])
            )
        end
        do -----------------------< misc >---------------------------
            menu.celestium.misc.backtrack = anomaly.other:combobox('\aCCCC6FFFbacktrack', {'default', 'normal', 'extended'}):depend(
                debug.unpack(__tabs[1][1])
            )
        end

    end)()end
    anim_sytem = eui:new(function()
        
    end)

    local diff = {tickbase_diff, tickbase_max, current_cmd}
    reset = function()
        diff.tickbase_max, diff.tickbase_diff = nil, nil
    end;
    reset()
    local L498 = function(L497)
        diff.current_cmd = L497.command_number
    end;
    local L501 = function(L499)
        if L499.command_number == diff.current_cmd then
            diff.current_cmd = nil;
            local L500 = entity.get_prop(entity.get_local_player(), 'm_nTickBase')
            if diff.tickbase_max ~= nil then
                diff.tickbase_diff = math.abs(L500 - diff.tickbase_max)
            end;
            diff.tickbase_max = math.max(L500, diff.tickbase_max or 0)
        end
    end;
    database['is_defensive'] = eui:new(function(pstat, cmd)
        local value = false
        if diff.tickbase_diff ~= nil and globals.chokedcommands() < 13 then
            if pstat['defensive:duration']:get() == 1 then
                value = diff.tickbase_diff > 2 and diff.tickbase_diff < 14
            elseif pstat['defensive:duration']:get() == 2 then
                value = diff.tickbase_diff > 2 and diff.tickbase_diff ~= 15
            elseif pstat['defensive:duration']:get() == 3 then
                value = diff.tickbase_diff > 1 and diff.tickbase_diff < 16
            elseif pstat['defensive:duration']:get() == 4 then
                value = diff.tickbase_diff > globals.chokedcommands() and diff.tickbase_diff < 14
            end
            if value then
                return true
            else
                return false
            end
        else
            return false
        end
    end)
    backtrack = eui:new(function()
        if menu.celestium.misc.backtrack:get() == 'default' then
            client.set_cvar('sv_maxunlag', 0.2)
        elseif menu.celestium.misc.backtrack:get() == 'normal' then
            client.set_cvar('sv_maxunlag', 0.4)
        elseif menu.celestium.misc.backtrack:get() == 'extended' then
            client.set_cvar('sv_maxunlag', 0.8)
        end
    end)
    client.set_event_callback('setup_command', function(cmd, e)
        backtrack:call()
    end)
    antiaim = eui:new(function(cmd)
        local flags = entity.get_prop(entity.get_local_player(), 'm_fFlags')
        local lp = entity.get_local_player( )
        local player_states = database['aa:states'](database)
        local GET_AA_STATE = builder[player_states]['enable']:get() and player_states or 1
        local pstat = builder[GET_AA_STATE]
        if bit.band(flags, bit.lshift(1, 0))~= 0 then 
            database.in_air_ticks = database.in_air_ticks + 1
        else 
            database.in_air_ticks = 0
        end
        FAKE_FLICK = eui:new(function()
            if menu.celestium.fakeflick:get() and menu.celestium.fakeflick_hotkey:get() then
                local screen_size, value = pcall(function()
                    return vector(client.screen_size()).x / 2
                end)
                local a, b = pcall(function()
                    return data.threat_origin
                end)
                local tickbase = eui:new(function()
                    return math.floor(entity.get_prop(entity.get_local_player(), 'm_nTickBase'))
                end)
                local get_ticks = eui:new(function(maximum, wait)
                    local value = nil
                    return(function()
                        if type(wait) == 'table' then
                            for i, v in pairs(wait) do
                                return {tickbase:call() % maximum == v, tickbase:call() % maximum}
                            end
                        else
                            return {tickbase:call() % maximum == wait, tickbase:call() % maximum}
                        end
                    end)()
                end)

                local set_yaw = function()
                    auto.refs.antiaim.desync[1]:override('static')
                    auto.refs.antiaim.desync[2]:override(0)
                    auto.refs.antiaim.jitter[1]:override('off')
                    auto.refs.antiaim.yaw[1]:override('180')
                    if a and screen_size then
                        if not b then
                            b = 0
                        end
                        if b > value then
                            auto.refs.antiaim.yaw[2]:override(90)
                        elseif b < value then
                            auto.refs.antiaim.yaw[2]:override(-90)
                        else
                            auto.refs.antiaim.yaw[2]:override(180)
                        end
                    end
                end
                if a and globals.chokedcommands() < 13 and bit.band(flags, 1) == 1 and database['velocity']() < 60 then
                    if menu.celestium.fakeflick.flick_type:get() == 'classic' then
                        if get_ticks:call(31, 17)[1] then
                            set_yaw()
                        end
                    elseif menu.celestium.fakeflick.flick_type:get() == 'slow' then
                        if get_ticks:call(21, {5, 17})[1] then
                            set_yaw()
                        end
                    elseif menu.celestium.fakeflick.flick_type:get() == 'fast' then
                        if get_ticks:call(9, {3, 7})[1] then
                            set_yaw()
                        end
                    elseif menu.celestium.fakeflick.flick_type:get() == 'random' then
                        if get_ticks:call(11, math.random(1, 10))[1] then
                            set_yaw()
                        end
                    end
                end
            end
        end)
        OTHER_YAWS = eui:new(function()
            local isleft = menu.celestium.manualyaw.left:get()
            local isright = menu.celestium.manualyaw.right:get()
            local isback = menu.celestium.manualyaw.back:get()
            local isforward = menu.celestium.manualyaw.forward:get()
            set_yaw = function(x)
                local diff = {
                    [1] = (function()if x[1] then return -90 end end),
                    [2] = (function()if x[2] then return 90 end end),
                    [3] = (function()if x[3] then return 0 end end),
                    [4] = (function()if x[4] then return -180 end end),
                }
                if x[1] then return diff[1]() 
                elseif x[2] then return diff[2]()
                elseif x[3] then return diff[3]()
                elseif x[4] then return diff[4]()
                end
            end
            if (isleft or isright or isback or isforward ) and menu.celestium.manualyaw:get() then
                auto.refs.antiaim.yaw[1]:override('180')
                auto.refs.antiaim.yaw[2]:override(set_yaw({isleft, isright, isback, isforward}))
            end
            if menu.celestium.freestanding:get() then
                if builder[11]['defensive:yaw']:get() ~= 'off' then
                    if database['is_defensive']:call(pstat, cmd) then
                        auto.refs.antiaim.freestand[1]:override(false)
                    else
                        auto.refs.antiaim.freestand[1]:override(true)
                    end
                else
                    auto.refs.antiaim.freestand[1]:override(true)
                end
                auto.refs.antiaim.freestand[1].hotkey:override({'Always on', 0})
            else
                auto.refs.antiaim.freestand[1]:override(false)
                auto.refs.antiaim.freestand[1].hotkey:override({'On hotkey', 0})
            end
            if menu.celestium.edgeyaaw:get() then
                auto.refs.antiaim.edgeyaw[1]:override(true)
            else
                auto.refs.antiaim.edgeyaw[1]:override(false)
            end
            auto.refs.antiaim.amount:override(menu.celestium.fakelag:get())
            auto.refs.antiaim.limit:override(15 or 14)
        end)
        SAFE_HEAD = eui:new(function()
            local get_weapon = entity.get_classname(entity.get_player_weapon(entity.get_local_player()))
            if menu.celestium.safehead:get() then
                if bit.band(flags, 1) == 0 and bit.band(flags, 4) == 4 then
                    if menu.celestium.safehead.weapons:get('knife') and get_weapon == 'CKnife' then
                        auto.refs.antiaim.pitch[1]:override('down')
                        auto.refs.antiaim.desync[1]:override('static')
                        auto.refs.antiaim.desync[2]:override(0)
                        auto.refs.antiaim.yaw[1]:override('180')
                        auto.refs.antiaim.yaw[2]:override(0)
                        auto.refs.antiaim.jitter[1]:override('off')
                    end
                    if menu.celestium.safehead.weapons:get('awp') and get_weapon == 'CWeaponAWP' then
                        auto.refs.antiaim.pitch[1]:override('down')
                        auto.refs.antiaim.desync[1]:override('static')
                        auto.refs.antiaim.desync[2]:override(0)
                        auto.refs.antiaim.yaw[1]:override('180')
                        auto.refs.antiaim.yaw[2]:override(0)
                        auto.refs.antiaim.jitter[1]:override('off')
                    end
                    if menu.celestium.safehead.weapons:get('taser') and get_weapon == 'CWeaponTaser' then
                        auto.refs.antiaim.pitch[1]:override('down')
                        auto.refs.antiaim.desync[1]:override('static')
                        auto.refs.antiaim.desync[2]:override(0)
                        auto.refs.antiaim.yaw[1]:override('180')
                        auto.refs.antiaim.yaw[2]:override(0)
                        auto.refs.antiaim.jitter[1]:override('off')
                    end
                    if menu.celestium.safehead.weapons:get('scout') and get_weapon == 'CWeaponSSG08' then
                        auto.refs.antiaim.pitch[1]:override('down')
                        auto.refs.antiaim.desync[1]:override('static')
                        auto.refs.antiaim.desync[2]:override(0)
                        auto.refs.antiaim.yaw[1]:override('180')
                        auto.refs.antiaim.yaw[2]:override(0)
                        auto.refs.antiaim.jitter[1]:override('off')
                    end
                end
            end
        end)
        ANTIAIM_BUILDER = eui:new(function()
            local get_weapon = entity.get_classname(entity.get_player_weapon(entity.get_local_player()))
            auto.refs.antiaim.desync[1]:override(pstat['desync']:get())
            auto.refs.antiaim.desync[2]:override(pstat['desync:offset1']:get())
            auto.refs.antiaim.yawbase:override(pstat['yawbase']:get() == 'local viewtopic' and 'local view' or 'at targets')
            if pstat['pitch']:get() ~= 'zero' and pstat['pitch']:get() ~= 'custom' then
                auto.refs.antiaim.pitch[1]:override(pstat['pitch']:get())
            else
                if pstat['pitch']:get() == 'zero' then
                    auto.refs.antiaim.pitch[1]:override('custom')
                    auto.refs.antiaim.pitch[2]:override(0)
                elseif pstat['pitch']:get() == 'custom' then
                    auto.refs.antiaim.pitch[1]:override('custom')
                    auto.refs.antiaim.pitch[2]:override(pstat['pitch:slider']:get())
                end
            end
            if pstat['yaw']:get() ~= 'random' and pstat['yaw']:get() ~= 'delay' then
                auto.refs.antiaim.yaw[1]:override(pstat['yaw']:get())
                auto.refs.antiaim.yaw[2]:override(pstat['yaw:offset1']:get() * 2)
            else
                if pstat['yaw']:get() == 'random' or pstat['yaw']:get() == 'delay' then
                    auto.refs.antiaim.yaw[1]:override('180')
                    if pstat['yaw']:get() == 'random' then
                        local yaw = pstat['yaw:offset1']:get() * 2 < 0 and math.abs(pstat['yaw:offset1']:get() * 2) or pstat['yaw:offset1']:get() * 2
                        auto.refs.antiaim.yaw[2]:override(client.random_int(-yaw, yaw))
                    elseif pstat['yaw']:get() == 'delay' then
                        local switch = database['delay:ticks'](pstat['yaw:delay:delay']:get(), cmd)
                        auto.refs.antiaim.yaw[2]:override(switch and pstat['yaw:delay:offset1']:get() * 1.5 or pstat['yaw:delay:offset2']:get() * 1.5)
                        auto.refs.antiaim.desync[2]:override(switch and -1 or 1)
                    end
                end
            end
            if pstat['jitter']:get() ~= 'sway' then
                auto.refs.antiaim.jitter[1]:override(pstat['jitter']:get())
                auto.refs.antiaim.jitter[2]:override(
                    pstat['jitter']:get() ~= 'center' and pstat['jitter:offset1']:get() or pstat['jitter:center1']:get() * 2
                )
            else
                if pstat['jitter']:get() == 'sway' then
                    local z = pstat['jitter:offset1']:get()
                    if z == 0 then
                        z = 1
                    end
                    local n = normalize(
                        ((cmd.command_number % z) * pstat['jitter:sway_speed']:get()),
                        'yaw'
                    )
                    print(n)
                    auto.refs.antiaim.jitter[1]:override('center')
                    auto.refs.antiaim.jitter[2]:override(n)
                end
            end
        end)
        AVOID_BACKSTAP = eui:new(function()
            local getx = database['enemy_distance']()
            if getx ~= nil and (getx.distance <= 380 and getx.weapon == 'CKnife' and menu.celestium.avoidbackstap:get()) then
                auto.refs.antiaim.yaw[1]:override('180')
                auto.refs.antiaim.yaw[2]:override(globals.tickcount() % 3 == 0 and math.random(-100, -180) or math.random(100, 180))
            end
        end)
        SETTINGS_BUILDER = eui:new(function()
            local sv_maxusrcmdprocessticks_ref = pui.reference('MISC', 'Settings', 'sv_maxusrcmdprocessticks2')
            if menu.celestium.extended_fakeduck:get() then
                if auto.refs.antiaim.fakeduck:get() then
                    sv_maxusrcmdprocessticks_ref:override(18)
                    auto.refs.antiaim.limit:override(17)
                else
                    sv_maxusrcmdprocessticks_ref:override(16)
                end
            else
                sv_maxusrcmdprocessticks_ref:override(16)
            end
        end)
        DEFENSIVE_BUILDER = eui:new(function()
            local set_pitch, set_yaw = eui:new(function(x)
                auto.refs.antiaim.pitch[1]:override('custom')
                auto.refs.antiaim.pitch[2]:override(
                    normalize(x, 'pitch')
                ) 
            end), eui:new(function(x, n)
                auto.refs.antiaim.yaw[1]:override(n == 'spin' and 'spin' or '180')
                auto.refs.antiaim.yaw[2]:override(
                    normalize(x, 'yaw')
                )
            end)
            if pstat['defensive:type']:get() == 'always on' then
                cmd.force_defensive = pstat['defensive']:get() and true or false
            elseif pstat['defensive:type']:get() == 'on peek' then
                database['enemy:visible'] = eui:new(function(x)
                    if not (entity.is_alive(x) and not entity.is_dormant(x)) then
                        return false
                    end
                    for i = 1, 18 do
                        if client.visible(entity.hitbox_position(x, i)) then
                            return true
                        end
                    end
                    return false
                end)
                cmd.force_defensive = database['enemy:visible']:call(client.current_threat()) == true and true or false
            elseif pstat['defensive:type']:get() == 'celestium' then
                cmd.force_defensive = pstat['defensive']:get() and true or false
            end
            local delay_random = eui:new(function(min, max, delay)
                delay = delay / 8 or 4
                local t = globals.tickcount() % delay == 0
                return(function()
                    if t then
                        memory.delay_number = client.random_int(min, max)
                    end
                    return memory.delay_number
                end)()
            end)
            local add_number = eui:new(function(n)
                n = n / 3 or 4
                return(function ()
                    memory.number = memory.number + n
                    return memory.number
                end)()
            end)
            if database['is_defensive']:call(pstat, cmd) == false then
                memory.invert_ways_switch = not memory.invert_ways_switch
            end
            memory.invert_ways = eui:new(function()
                if memory.invert_ways_switch then
                    return 90
                else
                    return -90
                end
            end)
            if database['is_defensive']:call(pstat, cmd) then
                if pstat['defensive:yaw']:get()  ~= 'off' then
                    auto.refs.antiaim.jitter[2]:override(0)
                    auto.refs.antiaim.jitter[1]:override('off')
                    auto.refs.antiaim.desync[1]:override('static')
                    auto.refs.antiaim.desync[2]:override(0)
                end
                local screen_size = vector(client.screen_size())
                if pstat['defensive:yaw']:get() == 'side' then
                    if data.threat_origin then
                        if data.threat_origin > screen_size.x / 2 then
                            set_yaw:call(
                                90
                            )
                        elseif data.threat_origin < screen_size.x / 2 then
                            set_yaw:call(
                                -90
                            )
                        else
                            set_yaw:call(
                                globals.tickcount() % 4 ~= 1 and 
                                -180 or 
                                180
                            )
                        end
                    else
                    end
                else
                    if pstat['defensive:yaw'] :get() == '180' then
                        set_yaw:call(
                                -180
                            )
                    elseif pstat['defensive:yaw']:get() == '360' then
                        set_yaw:call(
                            add_number:call(8)
                        )
                    elseif pstat['defensive:yaw']:get() == 'skitter' then
                        set_yaw:call(
                        (function()
                            local n = globals.tickcount() % 6
                            if n == 0 then
                                return client.random_int(-80, -100)
                            elseif n == 2 then
                                return client.random_int(-20, 20)
                            elseif n == 4 then
                                return client.random_int(80, 100)
                            else
                                return client.random_int(-180, 180)
                            end
                        end)()
                        )
                    elseif pstat['defensive:yaw']:get() == 'sideways' then
                        set_yaw:call(
                            cmd.command_number % 4 >= 2 and 
                            client.random_int(-85, -95) or 
                            client.random_int(95, 85)
                        )
                    elseif pstat['defensive:yaw']:get() == 'invertways' then
                        set_yaw:call(
                            memory.invert_ways:call()
                        )
                    elseif pstat['defensive:yaw']:get() == 'random' then
                        set_yaw:call(
                            client.random_int(-180, 180)
                        )
                    elseif pstat['defensive:yaw']:get() == 'delayed random' then
                            set_yaw:call(
                            delay_random:call(
                                -180, 
                                180,
                                pstat['defensive:yaw:custom']:get()
                            )
                        )
                    elseif pstat['defensive:yaw']:get() == 'spin' then
                        local latency = math.min(client.latency() * 132, 360)
                        set_yaw:call(
                            pstat['defensive:yaw:spin']:get() + 
                            (pstat['defensive:yaw:spin']:get() < 0 and -latency or latency), 
                            'spin'
                        )
                    elseif pstat['defensive:yaw']:get() == 'absolute spin' then
                        set_yaw:call(
                            80,
                            'spin'
                        )
                    elseif pstat['defensive:yaw']:get() == 'custom' then
                        set_yaw:call(
                            pstat['defensive:yaw:custom']:get()
                        )
                    end
                end
                if pstat['defensive:pitch']:get() == 'up' then
                    set_pitch:call(-89)
                elseif pstat['defensive:pitch']:get() == 'zero' then
                    set_pitch:call(0)
                elseif pstat['defensive:pitch']:get() == 'down' then
                    set_pitch:call(89)
                elseif pstat['defensive:pitch']:get() == 'random' then
                    set_pitch:call(client.random_int(-89, 89))
                elseif pstat['defensive:pitch']:get() == 'delayed random' then
                    set_pitch:call(delay_random:call(-89, 89, pstat['defensive:pitch:speed']:get()))
                elseif pstat['defensive:pitch']:get() == 'spin' then
                    set_pitch:call(add_number:call(pstat['defensive:pitch:speed']:get()))
                elseif pstat['defensive:pitch']:get() == 'skitter' then
                    set_pitch:call((function()
                        local t, n = globals.tickcount() % 6, 0
                        return(function()
                            if t == 0 then
                                return client.random_int(-89, -31)
                            elseif t == 2 then
                                return client.random_int(-25, 40)
                            elseif t == 4 then
                                return client.random_int(-45, -89)
                            else
                                return client.random_int(-51, 51)
                            end
                        end)()
                    end)())
                elseif pstat['defensive:pitch']:get() == 'custom' then
                    set_pitch:call(pstat['defensive:pitch:custom']:get())
                end
            end
        end)

        if bit.band(flags, 1) == 0 then
            memory.number_anim = 0x0
        else
            memory.number_anim = memory.number_anim + 0x1
        end
        if menu.masterkey:get() then
            ANTIAIM_BUILDER:call()
            DEFENSIVE_BUILDER:call()
            AVOID_BACKSTAP:call()
            SETTINGS_BUILDER:call()
            OTHER_YAWS:call()
            SAFE_HEAD:call()
            FAKE_FLICK:call()
        end
    end)
    
    local ffi_tp = ffi.typeof('void***')
    local ffi_ac = client.create_interface('client.dll', 'VClientEntityList003') or error('VClientEntityList003 wasnt found', 2)
    local ffi_rw = ffi.cast(ffi_tp, ffi_ac) or error('rawientitylist is nil', 2)
    local ffi_gc = ffi.cast('void*(__thiscall*)(void*, int)', ffi_rw[0][3]) or error('get_client_entity is nil', 2)
    local ffi_gn = ffi.cast('void*(__thiscall*)(void*, int)', ffi_rw[0][0]) or error('get_client_networkable_t is nil', 2)
    ffi.cdef([[
        struct animation_layer_t {
            char  pad_0000[20];
            uint32_t m_nOrder; //0x0014
            uint32_t m_nSequence; //0x0018
            float m_flPrevCycle; //0x001C
            float m_flWeight; //0x0020
            float m_flWeightDeltaRate; //0x0024
            float m_flPlaybackRate; //0x0028
            float m_flCycle; //0x002C
            void *m_pOwner; //0x0030 // player's thisptr
            char  pad_0038[4]; //0x0034
        };

        struct animstate_t1 {
            char pad[ 3 ];
            char m_bForceWeaponUpdate; //0x4
            char pad1[ 91 ];
            void* m_pBaseEntity; //0x60
            void* m_pActiveWeapon; //0x64
            void* m_pLastActiveWeapon; //0x68
            float m_flLastClientSideAnimationUpdateTime; //0x6C
            int m_iLastClientSideAnimationUpdateFramecount; //0x70
            float m_flAnimUpdateDelta; //0x74
            float m_flEyeYaw; //0x78
            float m_flPitch; //0x7C
            float m_flGoalFeetYaw; //0x80
            float m_flCurrentFeetYaw; //0x84
            float m_flCurrentTorsoYaw; //0x88
            float m_flUnknownVelocityLean; //0x8C
            float m_flLeanAmount; //0x90
            char pad2[ 4 ];
            float m_flFeetCycle; //0x98
            float m_flFeetYawRate; //0x9C
            char pad3[ 4 ];
            float m_fDuckAmount; //0xA4
            float m_fLandingDuckAdditiveSomething; //0xA8
            char pad4[ 4 ];
            float m_vOriginX; //0xB0
            float m_vOriginY; //0xB4
            float m_vOriginZ; //0xB8
            float m_vLastOriginX; //0xBC
            float m_vLastOriginY; //0xC0
            float m_vLastOriginZ; //0xC4
            float m_vVelocityX; //0xC8
            float m_vVelocityY; //0xCC
            char pad5[ 4 ];
            float m_flUnknownFloat1; //0xD4
            char pad6[ 8 ];
            float m_flUnknownFloat2; //0xE0
            float m_flUnknownFloat3; //0xE4
            float m_flUnknown; //0xE8
            float m_flSpeed2D; //0xEC
            float m_flUpVelocity; //0xF0
            float m_flSpeedNormalized; //0xF4
            float m_flFeetSpeedForwardsOrSideWays; //0xF8
            float m_flFeetSpeedUnknownForwardOrSideways; //0xFC
            float m_flTimeSinceStartedMoving; //0x100
            float m_flTimeSinceStoppedMoving; //0x104
            bool m_bOnGround; //0x108
            bool m_bInHitGroundAnimation; //0x109
            char m_pad[2];
            float m_flJumpToFall;
            float m_flTimeSinceInAir; //0x10A
            float m_flLastOriginZ; //0x10E
            float m_flHeadHeightOrOffsetFromHittingGroundAnimation; //0x112
            float m_flStopToFullRunningFraction; //0x116
            char pad7[ 4 ]; //0x11A
            float m_flMagicFraction; //0x11E
            char pad8[ 60 ]; //0x122
            float m_flWorldForce; //0x15E
            char pad9[ 462 ]; //0x162
            float m_flMaxYaw; //0x334
        };

    ]])
    local n_mLayers = function(a, b)
        b = b or 1;
        a = ffi.cast(ffi_tp, a)
        return ffi.cast('struct animation_layer_t**', ffi.cast('char*', a) + 0x2990)[0][b]
    end
    client.set_event_callback('pre_render', function(cmd)
        local lp = entity.get_local_player()
        if not lp or lp == nil then return end
        local self_index = c_entity.new(lp)
        local self_anim_state = self_index:get_anim_state()
        if not self_anim_state then
            return
        end
        local layer = menu.celestium.visual.animbreaker
        local set_layer = eui:new(function(index, value)
            return entity.set_prop(lp, 'm_flPoseParameter', value, index)
        end)

        local ffi_fl = ffi_gc(ffi_rw, lp)
        local ffi_gl = ffi_gn(ffi_rw, lp)
        local ffi_ee = ffi.cast('struct animstate_t1**', ffi.cast('char*', ffi.cast(ffi_tp, ffi_fl)) + 0x9960)[0]
        if ffi_fl == nil or ffi_gl == nil or ffi_ee == nil then
            return
        end;

        if layer:get('reset pitch on land') then
            if memory.number_anim > 2 and memory.number_anim < 65 then
                set_layer:call(12, 0.5)
            end
        end
        if layer:get('fallen legs') then
            set_layer:call(6, 1)
        end
        if layer:get('movelean') then
            local self_anim_overlay = self_index:get_anim_overlay(12)
            if not self_anim_overlay then
                return
            end
            if database['velocity']() > 3 then
                self_anim_overlay.weight = 1
            end
        end
        if layer:get('static legs') then
            auto.refs.antiaim.legmmovement:override('always slide')
            set_layer:call(0, 0)
        end
        if layer:get('earth quake') then
            ANIM = n_mLayers(ffi_fl, 12)
            ANIM.m_flWeight = client.random_float(0, 1)
        end
        if layer:get('blind') then
            ANIM_FLASHED = n_mLayers(ffi_fl, 9)
            ANIM_FLASHED.m_nSequence = 224;
            ANIM_FLASHED.m_flWeight = 1
        end
        if layer:get('kangoroo') then
            set_layer:call(3, client.random_float(0, 1))
            set_layer:call(6, client.random_float(0, 1))
            set_layer:call(7, client.random_float(0, 1))
        end
        if layer:get('smooth') then
            set_layer:call(2, 0)
        end
    end)

    client.set_event_callback('paint_ui', function()
        set_antiaimbot_visible(menu.masterkey:get())
        
        local target = client.current_threat()
        if target then 
           local threat_origin = vector(entity.get_origin(target)) 
           data.threat_origin = renderer.world_to_screen(threat_origin.x, threat_origin.y, threat_origin.z)
       end
    end)

    client.set_event_callback('paint_ui', function()
        set_antiaimbot_visible(menu.masterkey:get())
    end)
    client.set_event_callback('setup_command', function(cmd)
        antiaim:call(cmd)
    end)
    client.set_event_callback('setup_command', L498)
    client.set_event_callback('predict_command', L501)

    memory.menu_config_save = pui.setup({menu, builder})
    menu.celestium.export_fast_config:set_callback(function()
        local package = memory.menu_config_save:save()
        clipboard.set(json.stringify(package))
    end)
    menu.celestium.import_fast_config:set_callback(function()
        local package = json.parse(clipboard.get())
        memory.menu_config_save:load(package)
    end)
end)(pui.reference)
